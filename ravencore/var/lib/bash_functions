#
#                  RavenCore Hosting Control Panel
#                Copyright (C) 2005  Corey Henderson
#
#     This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#

# Set global variables for bash scripts

verbose=0

# when ran from the socket we don't have a path. export it here
export PATH="/sbin:/bin:/usr/sbin:/usr/bin"

# make sure the $RC_ROOT directory exists

if [ ! -d $RC_ROOT ]; then
    
    logger "RavenCore root directory $RC_ROOT doesn't exist"
    
    exit 1
    
fi

#

export RC_ROOT=$RC_ROOT

# get our command variables

. $RC_ROOT/etc/cmd_maps.base

# get our module's command variables

for i in $($_ls $RC_ROOT/etc/cmd_maps.* | $_grep -v '\.base$'); do
    
    . $i
    
done

# export our DIST variable, tells us which linux distribution we're running on

for i in `$_grep -o ' /.*' $RC_ROOT/etc/dist.map`; do

    if [ -f $i ]; then

	export DIST=$($_grep $i $RC_ROOT/etc/dist.map | $_awk '{print $1}')

	break

    fi

done

# find out if our useradd command supports the '-r' switch

$_useradd -h 2> /dev/stdout | $_grep '\-r' &> /dev/null

if [ $? -eq 0 ]; then
    USERADD_R="-r"
else
    USERADD_R=""
fi

# make sure paths and variables are correctly set

for tmp in httpd:HTTPD init.d:INITD httpd_modules:HTTPD_MODULES; do
    
# each value is ext:var
    
    ext=$($_echo $tmp | $_sed 's/:.*//')
    var=$($_echo $tmp | $_sed 's/.*://')
    
# set the variable
    
    eval $var=$($_cat $RC_ROOT/var/run/$ext.path 2> /dev/null)
    
# check to make sure the variable exists
    
    if [ ! -f "$(eval $_echo \$$var)" ] || [ ! -d "$(eval $_echo \$$var)" ]; then
	
        for i in $($_cat $RC_ROOT/etc/paths.$ext.local $RC_ROOT/etc/paths.$ext 2> /dev/null); do
	    
# the values in tis loop are either files or directories. If we get to the point where we need to
# have a difference, we'll just create two loops, one with a -f and the other with a -d
	    
            if [ -f $i ] || [ -d $i ]; then
		
                eval $var=$i
		
                $_echo $i > $RC_ROOT/var/run/$ext.path
		
                break
		
            fi
	    
        done
	
    fi
    
# if we get here and the value of $var is not set as a variable, die with an error
    
    if [ -z $(eval "if [ -n \"\$$var\" ]; then $_echo hello; fi") ]; then
	
        $_echo "System variable $var is unset, unable to determine path"
	
        exit 1
	
    fi
    
done

# set the name of the system init script for apache. for now, assume it's the basename
# of the $HTTPD path

HTTPD_INIT=$($_basename $HTTPD)

# make sure database.cfg and .shadow exist
$_touch $RC_ROOT/database.cfg $RC_ROOT/.shadow

# load the database config file

. $RC_ROOT/database.cfg

# The password should be contained on a single line in a file readable only by rcadmin
MYSQL_ADMIN_PASS=$($_cat $RC_ROOT/.shadow)

# This is the string which is used to connect to the database
MYSQL_STR="$_mysql -h $MYSQL_ADMIN_HOST -u $MYSQL_ADMIN_USER -p$MYSQL_ADMIN_PASS $MYSQL_ADMIN_DB"

# This is the NEW string which is used to connect to the database

DATA_QUERY="$_perl -I $RC_ROOT/var/lib $RC_ROOT/sbin/data_query"

# string to run commands in $RC_ROOT/bin with

RUN_CMD="$_perl $RC_ROOT/sbin/run_cmd"

# find the real name of the service script to start mysqld

mysql_service=$($_basename $($_ls /etc/init.d/mysql* | $_head -n1))

# function to die on mysql connect error, and log it to the system logger

mysql_die() {
    
    logger -t ravencore "Unable to connect to database"
    
    exit 1

}

# This tests the database connection with the defined information
# if INIT_RUNNING is set, then we bypass this check as well, as our rc.sock won't exist yet

[ -z "$GOT_CONF" ] && [ -z "$INIT_RUNNING" ] && [ -z "$($DATA_QUERY 'select now()')" ] && mysql_die

# we export all our variables, so any subshells ran will have them. We only need to do this once

# check for our GOT_CONF variable, if it exists, we can assume our conf variables are already set

if [ -z "$GOT_CONF" ]; then

# get settings variables from database, and export them
    
    for i in $($DATA_QUERY "select concat(setting,'=',value) from settings"); do
	
	export $i
	
    done

# set our error num to zero for our conf check
    
    conf_err=0
    
# get required conf variables, and check for their existance. the "asdfasdf 2> /dev/null" was a quick
# hack to be sure that the cat command actually has at leat one file to try, or else we would freeze here
# in some cases

    for i in `$_cat $(for e in $($_ls $RC_ROOT/conf.d); do if [ -x $RC_ROOT/conf.d/$e ]; then $_echo $RC_ROOT/conf.d/$e; fi; done) asdfasdf 2> /dev/null | $_grep -v "^#" | $_sed 's/=.*//g'`; do
	
	export | $_sed 's/=/ /g' | $_awk '{print $3}' | $_grep $i &> /dev/null

	if [ $? -ne 0 ]; then
	    
	    logger -t ravencore "non existant variable: $i"
	    
	    conf_err=1
	    
	fi
	
    done
    
# if conf_err is 1, we don't have all our required varieables. exit out w/ error
    
    if [ $conf_err -eq 1 ]; then
	
	logger -t ravencore "Unable to load all required settings from database, exiting."

# only die with this error when we are not the init script
	
        [ -z "$INIT_RUNNING" ] && exit 1
	
    else 

# export our GOT_CONF variable so we don't need to do this agian
	
	export GOT_CONF=1
	
    fi

fi

# some defined variables that we can't change

WEB_SERVER_GROUP=servgrp

# A function to echo the given input, if verbose is set to 1

v_echo() {

    if [ $verbose -eq 1 ]; then

        $_echo $1

    fi

}

# A function to do just what it says... rebuild a conf file

rebuild_conf_file() {

    conf=$1
    service=$2
    seperator=$3
    is_in=$4

    conf_basename=$($_basename $conf)

#
# TODO: append a header to each conf file, saying that it was created by ravencore
#       on $x date, and that if you wan't to edit it, create a .local file and edit
#       that instead
#

    $_mkdir -p $($_dirname $conf)
    $_touch $conf
    
    if [ -f $RC_ROOT/etc/$conf_basename.in ] && [ -n "$is_in" ]; then
	
# .local support for the .in files
	dot_local=""
	[ -f $RC_ROOT/etc/$conf_basename.in.local ] && dot_local=.local
	
	$_cat $RC_ROOT/etc/$conf_basename.in$dot_local | while read -r line; do
	    
# code to replace all $_[VAR_NAME] in the files with bash variables from the database
	    
	    for in_var_name in $($_echo $line | $_grep -o '\$_\[[_A-Z]*\]'); do
		
# remove the $_[ and ] from the variable name
		
		in_var_name=$($_echo $in_var_name | $_sed 's/\$_\[//' | $_sed 's/\]//')
		
# evaluate it to get the bash variable value
		
		in_var_value=$(eval $_echo $($_echo \$$in_var_name))
		
# replace the variable with the bash value
		
		line=$($_echo -E $line | $_sed "s|\$_\[$in_var_name\]|$in_var_value|")
		
	    done
	    
	    $_echo -E "$line"
	    
	done > $RC_ROOT/var/tmp/$conf_basename.$$
	
    elif [ -d $RC_ROOT/etc/$service/$conf_basename ]; then
	
# look in the service config file directory, and get all the files, .local being the preference, and
# using a .local file even if a base file doesn't exist for it
	
# first we find a list of the distros, to ignore files that end with .dist, seperated by the | character
	
	dist_list=$($_echo $($_awk ' ! /^#/ {print $1}' $RC_ROOT/etc/dist.map) | $_sed 's/ /|/g')
	
# add ignore and local to the list, because we're not going to look at files
# ending in .local or .ignore either
	
	dist_list="$dist_list|local|ignore"
	
# old code, doesn't account for .local files that don't have a base file
#           for i in `$_ls -1 $RC_ROOT/etc/$service/$conf_basename | $_grep -v '\.local$'`; do
	
	for i in `$_echo $($_ls -1 $RC_ROOT/etc/$service/$conf_basename | $_awk " ! /\.($dist_list)$/") $($_ls -1 $RC_ROOT/etc/$service/$conf_basename | $_grep '\.local$' | $_sed 's/\.local$//') | $_tr ' ' '\n' | $_sort | $_uniq`; do
	    
	    param_name="$RC_ROOT/etc/$service/$conf_basename/$i"
	    
# skip this if there is a .ignore file for this directive
	    
	    if [ ! -f $param_name.ignore ]; then
		
# check to see if this directive has a customized file for this linux distro
		
		[ -f $param_name.$DIST ] && param_name=$param_name.$DIST
		
# use the .local file instead, if it exists
		
		[ -f $param_name.local ] && param_name=$param_name.local
		
		case `$_cat $param_name` in
		    "")
			$_echo -e "$i$seperator"
			;;
		    
		    *)
			$_cat $param_name | while read -r param_value; do
			    
# code to replace all $_[VAR_NAME] in the files with bash variables from the database
			    
			    for in_var_name in $($_echo $param_value | $_grep -o '\$_\[[_A-Z]*\]'); do
				
# remove the $_[ and ] from the variable name
				
				in_var_name=$($_echo $in_var_name | $_sed 's/\$_\[//' | $_sed 's/\]//')
				
# evaluate it to get the bash variable value
				
				in_var_value=$(eval $_echo $($_echo \$$in_var_name))
				
# replace the variable with the bash value
				
				param_value=$($_echo -E $param_value | $_sed "s|\$_\[$in_var_name\]|$in_var_value|")
				
			    done
			    
			    $_echo -ne "$i"
			    $_echo -ne "$seperator"
			    $_echo -E "$param_value"
			    
			done
			;;
		esac
		
	    fi # ! -f .ignore
	    
	done > $RC_ROOT/var/tmp/$conf_basename.$$
	
    fi
    
#
    
    if [ -f $RC_ROOT/var/tmp/$conf_basename.$$ ]; then
	
	$_diff $conf $RC_ROOT/var/tmp/$conf_basename.$$ &> /dev/null
	
	if [ $? -ne 0 ]; then
	    
# if the sys_orig file for the conf file doesn't exist,
	    if [ ! -f $conf.sys_orig ]; then
		
# then save the conf file as the sys_orig. This will preserve the system's origonal configuration
# so when we uninstall ravencore, they will be moved back
		$_mv $conf $conf.sys_orig
		
# tell ravencore that this sys_orig file was made by appending it to our sys_orig list
		$_echo "$service:$conf" >> $RC_ROOT/var/run/sys_orig_conf_files
		
	    fi
	    
	    $_rm -f $conf
	    
	    $_cp $RC_ROOT/var/tmp/$conf_basename.$$ $conf
	    
	    if [ -n "$INIT_RUNNING" ]; then
		
		$_echo "The config file $conf_basename for $service has been modified...rebuilding it and restarting $service"
		
		$INITD/$service restart
		
	    else
		
		$INITD/$service restart &> /dev/null
		
	    fi
	    
	fi
	
	$_rm -f $RC_ROOT/var/tmp/$conf_basename.$$
	
    fi
    
}


# 

do_dependency_check()
{

    $_echo "Running dependency check...."

    for i in $($_ls $RC_ROOT/conf.d | $_awk '/\.conf$/ {print}'); do

        conf=$($_echo $i | $_sed 's/\.conf$//')

        $_echo -n "checking $conf...."

        if [ -x $RC_ROOT/conf.d/$conf.conf ]; then

            $_echo "ok"

        else

            $_echo "failed"

# a failed base configuration check is a fatal error

            [ $conf = "base" ] && $_echo "base configuration is missing dependencies... see above warnings for details. exiting!" && exit 1

        fi

    done

}

