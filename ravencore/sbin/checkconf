#!/bin/bash
#
#                  RavenCore Hosting Control Panel
#                Copyright (C) 2005  Corey Henderson
#
#     This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#

# we don't want to require a database connection, so say we already have one
# so bash_functions doesn't attempt to read the database configuration

export GOT_CONF=1

. /etc/ravencore.conf || exit 1

reload_ravencore=0

# make sure $HTTPD exists. This variable was set by bash_functions. If not set, we can't find the path
# to the apache server binary

if [ ! -f $HTTPD ]; then

    echo "Fatal error: unable to find apache binary. If apache is already installed, then"
    echo "   we can't find it. Please add the full path to the apache binary to this file: "
    echo "   $RC_ROOT/etc/paths.httpd.local"
    echo

# create the file for them so they don't get confused about it not existing

    touch $RC_ROOT/etc/paths.httpd.local

    exit 1

fi

# check to see what version we are now, vs what version we were when we ran last time

cat $RC_ROOT/var/run/version 2> /dev/null | diff $RC_ROOT/etc/version - &> /dev/null

if [ $? -ne 0 ]; then
    
# we are a different version of ravencore. Remove everything in the var/run/ directory
    
# only say our version number changed if we actually had a previous version
    
    [ -f $RC_ROOT/var/run/version ] && echo "Version number changed since we last ran, running upgrade steps"
    
# remove the db_install so that we'll run that script
# remove the gpl_check so they can agree to the license, just incase the GPL version number changes
# remove the version so we can copy the new one there
# remove the wrapper, it'll be added back later in this script, from the newer version's code

    rm -f $RC_ROOT/var/run/{db_install,gpl_check,version} $RC_ROOT/sbin/wrapper

# copy the new version to the run cache

    cp $RC_ROOT/etc/version $RC_ROOT/var/run/version

fi

# check to see if our db_install script ran

if [ ! -f $RC_ROOT/var/run/db_install ]; then

# install the ravencore database
    $RC_ROOT/sbin/db_install
    
# check to see if it exited cleanly
    
    [ $? -ne 0 ] && exit 1
    
fi

# make sure that ravencore is a listed service

if [ -x /sbin/chkconfig ]; then
    
    /sbin/chkconfig --list ravencore &> /dev/null

    if [ $? -ne 0 ]; then

# not listed as a service, add it
        /sbin/chkconfig --add ravencore
# set ravencore to startup on boot. Some distrobutions complain about setting more than one
# runlevel with a single chkconfig command, so we'll run 3 of them instead
        for runlevel in 3 4 5; do
	    /sbin/chkconfig --level $runlevel ravencore on
	done
	
    fi
    
fi

# make sure the servgrp exists

groupmod -g 149 servgrp 2> /dev/null

if [ $? -ne 0 ]; then
    
    groupadd -g 149 servgrp
    
# we need to figure out what user this system is configured to run apache as, so we can add it to servgrp
    
# if apache is running, see what users it is running as
    
    httpd_user=$(for i in `pidof $HTTPD`; do ls -dal /proc/$i; done | awk '!/root/{print $3}' | head -n 1)

# we won't have $httpd_user set if apache isn't running. Try to figure out the user from the conf file

    if [ -z "$httpd_user" ]; then

# get the compiled in server root and server config file
	httpd_server_root=$($HTTPD -V | grep HTTPD_ROOT | sed 's/=/ /' | awk '{print $3}' | sed 's/"//g')
	httpd_config_file=$($HTTPD -V | grep SERVER_CONFIG_FILE | sed 's/=/ /' | awk '{print $3}' | sed 's/"//g')

# look for the path to the apache conf file
	
	if [ -f $httpd_server_root/$httpd_config_file ]; then
	    
	    httpd_config_file="$httpd_server_root/$httpd_config_file"
	    
	elif [ ! -f $httpd_config_file ]; then

# if there is no file existing in $httpd_server_root/$httpd_config_file or $httpd_config_file , then
# we can't look up what user apache will run as
	    
	    echo "Unable to find apache's compiled in configuration file"
	    echo "HTTPD_ROOT=$httpd_server_root"
	    echo "SERVER_CONFIG_FILE=$httpd_config_file"
	    
	    exit 1
	    
	fi
	
# find the user from the httpd conf file
	httpd_user=$(grep "^User" $httpd_config_file | awk '{print $2}')

# if the user is not found, we can't add it to the servgrp, and vhosts won't work

	if [ -z "$httpd_user" ]; then
	    
	    echo "Unable to find the user apache runs as from its configuration file $httpd_config_file"
	    
	    exit 1

	fi


    fi

    users_in_httpd_group=$(grep "^$httpd_user" /etc/group | sed 's/:/ /g' | awk '{print $4}')

# if there are users, be sure to use a comma
    if [ -n "$users_in_httpd_group" ]; then
	
	usermod -G $users_in_httpd_group,servgrp $httpd_user
	
    else
	
	usermod -G servgrp $httpd_user

    fi

fi

# make sure we have the rcadmin user / group
# check the group first, because in order to add the user, we need a valid existing gid

groupmod -g 147 rcadmin 2> /dev/null

[ $? -ne 0 ] && groupadd -g 147 rcadmin

# 

usermod -u 147 -G servgrp rcadmin &> /dev/null

[ $? -ne 0 ] && useradd -M -u 147 -g 147 -G servgrp -d $RC_ROOT -s /bin/false rcadmin

# Set correct ownership and permissions so that the panel can read the .shadow file
chown rcadmin:rcadmin $RC_ROOT/.shadow $RC_ROOT/database.cfg
chmod 600 $RC_ROOT/.shadow $RC_ROOT/database.cfg
# make sure all the directories are readable
# TODO: figure out what could be tightened up with 750 permissions or something
chmod 755 $RC_ROOT/{.,bin,sbin,conf.d,httpdocs,etc,var}
chown root:root $RC_ROOT/{.,bin,sbin,conf.d,httpdocs,etc,var}
# make sure all the appropriate tmp directories are owned by root:rcadmin and set to 770
chown root:rcadmin $RC_ROOT/var/{tmp,run} $RC_ROOT/httpdocs/{webmail/{data,data/default_pref},filemanager/tmp}
chmod 770 $RC_ROOT/var/{tmp,run} $RC_ROOT/httpdocs/{webmail/{data,data/default_pref},filemanager/tmp}

# check to see if the wrapper was installed

if [ ! -x $RC_ROOT/sbin/wrapper ]; then

# attempt to compile the wrapper code

    gcc -o $RC_ROOT/sbin/wrapper $RC_ROOT/sbin/wrapper.c &> /dev/null

# if we failed, 

    if [ $? -ne 0 ]; then

# use the perl wrapper code instead

# we can test to see if perl has suid enabled the exit status of doing: perl -V | grep suid &> /dev/null
# but for now, leave the control panel interface to handling this error

	rm -f $RC_ROOT/sbin/wrapper
	cp $RC_ROOT/sbin/wrapper.pl $RC_ROOT/sbin/wrapper
	
    fi
    
fi

# make sure the wrapper has correct ownership / permissions
chown root:rcadmin $RC_ROOT/sbin/wrapper
chmod 4150 $RC_ROOT/sbin/wrapper

# Check if we don't have something in the server-id.conf file

SERVER_ID=$(cat $RC_ROOT/etc/server-id 2> /dev/null)
if [ -z "$SERVER_ID" ]; then
# 16 item long string with randomly generated letters ( from A to Z )
    perl -e 'for($i=0;$i<16;$i++) {print pack("C",int(rand(26))+65)}; print "\n"' > $RC_ROOT/etc/server-id
fi

# make sure the path to these directories are correct

for dir in httpd_modules; do

    if [ ! -d "$(cat $RC_ROOT/var/run/$dir.path 2> /dev/null)" ]; then
	
	for path in `cat $RC_ROOT/etc/paths.$dir.local $RC_ROOT/etc/paths.$dir 2> /dev/null`; do
	    
# check to see if this directory is in /usr/lib
	    if_lib_dir=$(echo $path | sed 's|/usr/lib/.*|/usr/lib|')
	    
# if so, if_lib_dir will equil "/usr/lib"

	    if [ $if_lib_dir = "/usr/lib" ]; then
		
# set the possible equiv of this $path if we are x86_64

		path_64=$(echo $path | sed 's|/usr/lib/|/usr/lib64/|')
		
		if [ -d $path_64 ]; then
		    echo $path_64 > $RC_ROOT/var/run/$dir.path
		    
		    reload_ravencore=1
    
		fi
		
	    fi
	    
	    if [ -d $path ] && [ ! -d $path_64 ]; then
		
		echo $path > $RC_ROOT/var/run/$dir.path
		
		reload_ravencore=1
		
		break;
		
	    fi
	    
	done
	
    fi

done

# check to make sure /bin/false is listed in /etc/shells

if [ -f /etc/shells ]; then
    
    grep "/bin/false" /etc/shells &> /dev/null
    
    [ $? -ne 0 ] && echo "/bin/false" >> /etc/shells
    
fi
    
# check to make sure the session.save_path for php is correct, in case the $RC_ROOT variable changes

echo "php_admin_value session.save_path $RC_ROOT/var/tmp" | diff $RC_ROOT/var/run/session.include - &> /dev/null

if [ $? -ne 0 ]; then

    echo "php_admin_value session.save_path $RC_ROOT/var/tmp" > $RC_ROOT/var/run/session.include

    reload_ravencore=1

fi

# make sure the system httpd binary matches what we have running ravencore

diff $HTTPD $RC_ROOT/sbin/ravencore.httpd &> /dev/null

if [ $? -ne 0 ]; then

    rm -f $RC_ROOT/sbin/ravencore.httpd

    cp -p $HTTPD $RC_ROOT/sbin/ravencore.httpd

    reload_ravencore=1

fi

# check to make sure the vsftpd.conf file is correct

[ -f /etc/vsftpd.conf ] && vsftpd_conf=/etc/vsftpd.conf
[ -f /etc/vsftpd/vsftpd.conf ] && vsftpd_conf=/etc/vsftpd/vsftpd.conf

if [ -n "$vsftpd_conf" ]; then

# set the vsftpd.conf file to be tested against. the local file will be used if it exists

    vsftpd_conf_in=$RC_ROOT/etc/vsftpd.conf.in
    [ -f $vsftpd_conf_in.local ] && vsftpd_conf_in=$vsftpd_conf_in.local

# only proceed if we actually got the $vsftpd_conf_in set

    diff $vsftpd_conf $vsftpd_conf_in &> /dev/null
    
    if [ $? -ne 0 ]; then
	
	rm -f $vsftpd_conf
	cp $vsftpd_conf_in $vsftpd_conf
	    
	$INITD/vsftpd restart &> /dev/null
	
    fi

fi

# check to see if we need to restart ravencore

if [ $reload_ravencore -ne 0 ]; then

# only call a restart if we are not being run by the init script itself

    if [ -z "$INIT_RUNNING" ]; then

	$INITD/ravencore status &> /dev/null

# only restart if ravencore is running
	
	if [ $? -eq 0 ]; then

	    $INITD/ravencore restart &> /dev/null

	fi

    fi

fi

# here, figure out what "services" are installed, and set the "x" bit on the conf.d file accordingly

# we are base :) always set with +x

chmod +x $RC_ROOT/conf.d/base.conf

# for now, web and mysql are always here also

chmod +x $RC_ROOT/conf.d/{web,mysql}.conf

# is postfix installed?

if [ -f /usr/sbin/postfix ]; then

    chmod +x $RC_ROOT/conf.d/mail.conf

else

    chmod -x $RC_ROOT/conf.d/mail.conf

fi

# is spamassassin installed?

if [ -f /usr/bin/spamc ]; then

    chmod +x $RC_ROOT/conf.d/mailscan.conf

else

    chmod -x $RC_ROOT/conf.d/mailscan.conf

fi

# is bind installed?

if [ -f /usr/sbin/named ]; then

    chmod +x $RC_ROOT/conf.d/dns.conf

else

    chmod -x $RC_ROOT/conf.d/dns.conf

fi


#generate ssl cert for panel

if [ -x /usr/bin/openssl ]; then

    umask 077

# generate the key if non-existant
    
    if [ ! -f $RC_ROOT/etc/server.key ]; then
    
	echo -n "Creating control panel SSL key file...."

	/usr/bin/openssl genrsa -rand /proc/apm:/proc/cpuinfo:/proc/dma:/proc/filesystems:/proc/interrupts:/proc/ioports:/proc/pci:/proc/rtc:/proc/uptime 1024 > $RC_ROOT/etc/server.key 2> /dev/null
	
	echo "done"

    fi
    
# generate the cert if non-existant

    if [ ! -f $RC_ROOT/etc/server.crt ]; then

	echo -n "Creating control panel SSL cert file...."

	FQDN=`hostname`
	if [ "x${FQDN}" = "x" ]; then
	    FQDN=localhost.localdomain
	fi
	
	cat << EOF | /usr/bin/openssl req -new -key $RC_ROOT/etc/server.key -x509 -days 365 -out $RC_ROOT/etc/server.crt 2>/dev/null
--
SomeState
SomeCity
SomeOrganization
SomeOrganizationalUnit
${FQDN}
root@${FQDN}
EOF
	
	echo "done"

    fi
    
fi

# check for a local script to run, and run it if it is executeable

[ -x $RC_ROOT/sbin/checkconf.local ] && $RC_ROOT/sbin/checkconf.local

# exit cleanly... $? is set to 1 if the above didn't happen 

exit 0
