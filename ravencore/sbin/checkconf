#!/bin/bash
#
#                  RavenCore Hosting Control Panel
#                Copyright (C) 2005  Corey Henderson
#
#     This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#

# we don't want to require a database connection, so say we already have one
# so bash_functions doesn't attempt to read the database configuration

#export GOT_CONF=1

. /etc/ravencore.conf || exit 1

reload_ravencore=0

# make sure $HTTPD exists. This variable was set by bash_functions. If not set, we can't find the path
# to the apache server binary

if [ ! -f $HTTPD ]; then

    $_echo "Fatal error: unable to find apache binary. If apache is already installed, then"
    $_echo "   we can't find it. Please add the full path to the apache binary to this file: "
    $_echo "   $RC_ROOT/etc/paths.httpd.local"
    $_echo

# create the file for them so they don't get confused about it not existing

    $_touch $RC_ROOT/etc/paths.httpd.local

    exit 1

fi

# TODO: search for mime.types elsewhere and make a symlink
# for now, just require that it exists

if [ ! -f /etc/mime.types ]; then

    $_echo "Fatal error: /etc/mime.types does not exist"

    exit 1

fi

# check to see what version we are now, vs what version we were when we ran last time

$_cat $RC_ROOT/var/run/version 2> /dev/null | $_diff $RC_ROOT/etc/version - &> /dev/null

[ $? -ne 0 ] && first_time_run=1

# first thing we want to do is check our module dependencies and mark them enabled or not

for conf in $($_ls $RC_ROOT/conf.d | $_awk '/\.conf$/ {print}'); do
    
# parse our conf name out

    conf=$($_echo $conf | $_sed 's/\.conf$//')
    
# unset our dep_check flag

    dep_check_failed=0

# loop thru the dependencies of this module
# if the dependency file doesn't exist, this loop won't happen, and we assume that it's OK that this
# module be enabled

    for dep in $($_cat $RC_ROOT/etc/dependencies.$conf 2> /dev/null); do
	
# look for the actual command name of this dependency

	cmd=$($_basename $($_grep "_$dep=" $RC_ROOT/etc/cmd_maps.$conf | $_sed 's/.*=//'))

# walk down our $PATH to see if it exists somewhere. If so, break out of the loop
	
	for dir in `$_echo $PATH | $_sed 's/:/ /g'`; do [ -x $dir/$cmd ] && break; done

# if it isn't found anywhere in $PATH, we'll have $? set to non-zero
	
	if [ $? -ne 0 ]; then

	    dep_check_failed=1

	    [ -n "$first_time_run" ] && $_echo "WARNING: dependancy '$dep' not found for $conf module. Search path is $PATH"
	
	fi

    done

# toggle our conf file with the executable bit, based on if the module has all its dependencies

    [ $dep_check_failed -eq 1 ] && $_chmod -x $RC_ROOT/conf.d/$conf.conf || $_chmod +x $RC_ROOT/conf.d/$conf.conf
    
done

# check to see if we're running the first time after a fresh install or upgrade

if [ -n "$first_time_run" ]; then
    
# we are a different version of ravencore. Remove some things from the var/run/ directory
    
# only say our version number changed if we actually had a previous version
    
    [ -f $RC_ROOT/var/run/version ] && $_echo "Version number changed since we last ran, running upgrade steps"

# do dependency check

    do_dependency_check

# remove the install_complete so our interface will know to run all the rehash scripts when the conf is complete
# remove the db_install so that we'll run that script
# remove the gpl_check so they can agree to the license, just incase the GPL version number changes
# remove the version so we can copy the new one there

    $_rm -f $RC_ROOT/var/run/{install_complete,db_install,gpl_check,version}

# copy the new version to the run cache

    $_cp $RC_ROOT/etc/version $RC_ROOT/var/run/version

# change the runlevel of all the services listed in etc, if they exist

    $_echo -n "Setting service runlevels...."

    if [ -x $_chkconfig ]; then
	
	for i in `$_cat $RC_ROOT/etc/services.*`; do

	    $_chkconfig --list $i &> /dev/null

# if this service exists in chkconfig
	    if [ $? -eq 0 ]; then
		
# runlevel with a single chkconfig command, so we'll run 3 of them instead
		for runlevel in 3 4 5; do
		    $_chkconfig --level $runlevel $i on &> /dev/null
		done

	    fi
		
	done

    fi

    $_echo "done"

fi

# make sure that ravencore is a listed service

if [ -x $_chkconfig ]; then
    
    $_chkconfig --list ravencore &> /dev/null

    if [ $? -ne 0 ]; then

# not listed as a service, add it
        $_chkconfig --add ravencore
# set ravencore to startup on boot. Some distrobutions complain about setting more than one
# runlevel with a single chkconfig command, so we'll run 3 of them instead
        for runlevel in 3 4 5; do
	    $_chkconfig --level $runlevel ravencore on
	done
	
    fi
    
fi

# make sure the servgrp exists

$_groupmod servgrp &> /dev/null

if [ $? -ne 0 ] || [ ! -f "$RC_ROOT/var/run/httpd_user" ]; then
    
    $_groupadd $USERADD_R servgrp 2> /dev/null
    
# we need to figure out what user this system is configured to run apache as, so we can add it to servgrp
    
# if apache is running, see what users it is running as
    
    httpd_user=$(for i in `$_pidof $HTTPD`; do $_ls -dal /proc/$i; done | $_awk '!/root/{print $3}' | $_head -n 1)

# we won't have $httpd_user set if apache isn't running. Try to figure out the user from the conf file

    if [ -z "$httpd_user" ]; then

# get the compiled in server root and server config file
	httpd_server_root=$($HTTPD -V | $_grep HTTPD_ROOT | $_sed 's/=/ /' | $_awk '{print $3}' | $_sed 's/"//g')
	httpd_config_file=$($HTTPD -V | $_grep SERVER_CONFIG_FILE | $_sed 's/=/ /' | $_awk '{print $3}' | $_sed 's/"//g')

# look for the path to the apache conf file
	
	if [ -f $httpd_server_root/$httpd_config_file ]; then
	    
	    httpd_config_file="$httpd_server_root/$httpd_config_file"
	    
	elif [ ! -f $httpd_config_file ]; then

# if there is no file existing in $httpd_server_root/$httpd_config_file or $httpd_config_file , then
# we can't look up what user apache will run as
	    
	    $_echo "Unable to find apache's compiled in configuration file"
	    $_echo "HTTPD_ROOT=$httpd_server_root"
	    $_echo "SERVER_CONFIG_FILE=$httpd_config_file"
	    
	    exit 1
	    
	fi
	
# find the user from the httpd conf file
        httpd_user=$($_grep "^User" $httpd_config_file | $_awk '{print $2}')

# if not found, search the conf files it includes ( ex: SuSE looks in uid.conf )

        if [ -z "$httpd_user" ]; then

            for inc in `$_grep '^Include' $httpd_config_file 2> /dev/null`; do

                httpd_user=$($_grep "^User" $inc | $_awk '{print $2}' 2> /dev/null)

# if we found the user, break out of the loop

                if [ -n "$httpd_user" ]; then break; fi

            done

        fi

# if we still don't have the user, we can't add it to the servgrp, and vhosts won't work

        if [ -z "$httpd_user" ]; then

            $_echo "Unable to find the user apache runs as from its configuration file $httpd_config_file"

            exit 1

        fi

    fi

    users_in_httpd_group=$($_grep "^$httpd_user:" /etc/group | $_awk -F : '{print $4}')

# if there are users, be sure to use a comma
    if [ -n "$users_in_httpd_group" ]; then
	
	$_usermod -G $users_in_httpd_group,servgrp $httpd_user
	
    else
	
	$_usermod -G servgrp $httpd_user

    fi

    echo $httpd_user > $RC_ROOT/var/run/httpd_user

fi

httpd_user=$($_cat $RC_ROOT/var/run/httpd_user 2> /dev/null)

# make sure we have the rcadmin user / group
# check the group first, because in order to add the user, we need a valid existing gid

$_groupmod rcadmin &> /dev/null

[ $? -ne 0 ] && $_groupadd $USERADD_R rcadmin

# 

$_usermod -G servgrp rcadmin &> /dev/null

[ $? -ne 0 ] && $_useradd -M $USERADD_R -g rcadmin -G servgrp -d $RC_ROOT -s /bin/false rcadmin

# check to see if our db_install script ran

if [ ! -f $RC_ROOT/var/run/db_install ]; then

# install the ravencore database
    $RC_ROOT/sbin/db_install
    
# check to see if it exited cleanly
    
    [ $? -ne 0 ] && exit 1
    
fi

# Check if we don't have something in the server-id.conf file

SERVER_ID=$($_cat $RC_ROOT/etc/server-id 2> /dev/null)
if [ -z "$SERVER_ID" ]; then
# 16 item long string with randomly generated letters ( from a to Z )
    $_perl -e 'for($i=0;$i<16;$i++) {$c=pack("C",int(rand(26))+65);print (int(rand(2))==0?$c:lc($c))}; print "\n"' \
	> $RC_ROOT/etc/server-id
fi

# make sure the path to these directories are correct

for dir in httpd_modules; do

    if [ ! -d "$($_cat $RC_ROOT/var/run/$dir.path 2> /dev/null)" ]; then
	
	for path in `$_cat $RC_ROOT/etc/paths.$dir.local $RC_ROOT/etc/paths.$dir 2> /dev/null`; do
	    
# check to see if this directory is in /usr/lib
	    if_lib_dir=$($_echo $path | $_sed 's|/usr/lib/.*|/usr/lib|')
	    
# if so, if_lib_dir will equil "/usr/lib"

	    if [ $if_lib_dir = "/usr/lib" ]; then
		
# set the possible equiv of this $path if we are x86_64

		path_64=$($_echo $path | $_sed 's|/usr/lib/|/usr/lib64/|')
		
		if [ -d $path_64 ]; then
		    $_echo $path_64 > $RC_ROOT/var/run/$dir.path
		    
		    reload_ravencore=1
    
		fi
		
	    fi
	    
	    if [ -d $path ] && [ ! -d $path_64 ]; then
		
		$_echo $path > $RC_ROOT/var/run/$dir.path
		
		reload_ravencore=1
		
		break;
		
	    fi
	    
	done
	
    fi

done

# check to make sure /bin/false is listed in /etc/shells

if [ -f /etc/shells ]; then
    
    $_grep "/bin/false" /etc/shells &> /dev/null
    
    [ $? -ne 0 ] && $_echo "/bin/false" >> /etc/shells
    
fi
    
# check to make sure the session.save_path for php is correct, in case the $RC_ROOT variable changes

$_echo "php_admin_value session.save_path $RC_ROOT/var/tmp" | $_diff $RC_ROOT/var/run/session.include - &> /dev/null

if [ $? -ne 0 ]; then

    $_echo "php_admin_value session.save_path $RC_ROOT/var/tmp" > $RC_ROOT/var/run/session.include

    reload_ravencore=1

fi

# make sure the system httpd binary matches what we have running ravencore

$_diff $HTTPD $RC_ROOT/sbin/ravencore.httpd &> /dev/null

if [ $? -ne 0 ]; then

    $_rm -f $RC_ROOT/sbin/ravencore.httpd

    $_cp -p $HTTPD $RC_ROOT/sbin/ravencore.httpd

    reload_ravencore=1

fi

# check to make sure the vsftpd.conf file is correct

[ -f /etc/vsftpd.conf ] && vsftpd_conf=/etc/vsftpd.conf
[ -f /etc/vsftpd/vsftpd.conf ] && vsftpd_conf=/etc/vsftpd/vsftpd.conf

[ -n "$vsftpd_conf" ] && rebuild_conf_file $vsftpd_conf "vsftpd" "="

# check to make sure the proftpd.conf file is correct

[ -f /etc/proftpd.conf ] && proftpd_conf=/etc/proftpd.conf

[ -n "$proftpd_conf" ] && [ -z "$vsftpd_conf" ] && rebuild_conf_file $proftpd_conf "proftpd" "\t"

# set permissions and ownship of files in the ravencore root

# get rid of the wrapper, if it's still there

$_rm -f $RC_ROOT/sbin/wrapper

# start by giving everything root:rcadmin
$_chown -R root:rcadmin $RC_ROOT
# sbin files should not be in the rcadmin group
$_chown root:root $RC_ROOT/{bin,sbin}/*

# webmail files and tmp files should be owned by rcadmin
$_chown -R rcadmin:rcadmin $RC_ROOT/{database.cfg,var/tmp}
# but their directories should not be
$_chown root:rcadmin $RC_ROOT/var/tmp

# directory permissions.. start by issuing everything 750
$_chmod 750 $($_find $RC_ROOT -type d)

# files in sbin, etc, need to allow files that are readable to everyone, to be read
$_chmod 751 $RC_ROOT/{.,sbin,etc,var/{.,apps}}

# set sbin files to 500, with the exception of mailscan
$_chmod 500 $RC_ROOT/{bin,sbin}/*
$_chmod 555 $RC_ROOT/sbin/mailscan

$_chgrp servgrp $($_find $RC_ROOT/var/apps/squirrelmail -type d)
$_chmod 751 $($_find $RC_ROOT/var/apps/squirrelmail -type d)

$_chown -R rcadmin:servgrp $RC_ROOT/var/apps/squirrelmail/data
$_chmod 771 $RC_ROOT/var/{tmp,run} $RC_ROOT/var/apps/{squirrelmail/data,phpwebftp/tmp}

# make php files not world readable
$_chmod 640 $RC_ROOT/httpdocs/{*,*/*}php

# make sure our database connect info stays safe
$_chown root:root $RC_ROOT/.shadow
$_chmod 600 $RC_ROOT/.shadow
$_chmod 400 $RC_ROOT/database.cfg

# make sure that the vhosts.conf file exists and is readable by rcadmin and apache, but no one else
$_touch $RC_ROOT/etc/vhosts.conf
$_chgrp servgrp $RC_ROOT/etc/vhosts.conf
$_chmod 440 $RC_ROOT/etc/vhosts.conf

# remove the legacy socket
$_rm -f $RC_ROOT/db.sock
# make sure the socket has correct permissions. we /dev/null the output, the socket might not be there
$_chown rcadmin:root $RC_ROOT/var/rc.sock &> /dev/null
$_chmod 0600 $RC_ROOT/var/rc.sock &> /dev/null

# save our current umask state

old_umask=$(umask)

# generate ssl cert for panel

if [ -x $_openssl ]; then

    umask 077

# generate the key if non-existant
    
    if [ ! -f $RC_ROOT/etc/server.key ]; then
    
	$_echo -n "Creating control panel SSL key file...."

	$_openssl genrsa -rand /proc/apm:/proc/cpuinfo:/proc/dma:/proc/filesystems:/proc/interrupts:/proc/ioports:/proc/pci:/proc/rtc:/proc/uptime 1024 > $RC_ROOT/etc/server.key 2> /dev/null
	
	$_echo "done"

    fi
    
# generate the cert if non-existant

    if [ ! -f $RC_ROOT/etc/server.crt ]; then

	$_echo -n "Creating control panel SSL cert file...."

	FQDN=`hostname`
	if [ "x${FQDN}" = "x" ]; then
	    FQDN=localhost.localdomain
	fi
	
	$_cat << EOF | $_openssl req -new -key $RC_ROOT/etc/server.key -x509 -days 365 -out $RC_ROOT/etc/server.crt 2>/dev/null
--
SomeState
SomeCity
SomeOrganization
SomeOrganizationalUnit
${FQDN}
root@${FQDN}
EOF
	
	$_echo "done"

    fi
    
fi

# reload our old umask state

umask $old_umask

# run other checkconf scripts, but only if we're a complete install

[ -f $RC_ROOT/var/run/install_complete ] && $RC_ROOT/sbin/checkconf.cron.hourly

# check to see if we need to restart ravencore

if [ $reload_ravencore -ne 0 ]; then

# only call a restart if we are not being run by the init script itself

    if [ -z "$INIT_RUNNING" ]; then

	$INITD/ravencore status &> /dev/null

# only restart if ravencore is running
	
	if [ $? -eq 0 ]; then

	    $INITD/ravencore restart &> /dev/null

	fi

    fi

fi

# check for a local script to run, and run it if it is executeable

[ -x $RC_ROOT/sbin/checkconf.local ] && $RC_ROOT/sbin/checkconf.local

# exit cleanly... $? is set to 1 if the above didn't happen 

exit 0
