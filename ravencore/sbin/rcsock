#!/usr/bin/perl
#
#                  RavenCore Hosting Control Panel
#                Copyright (C) 2005  Corey Henderson
#
#     This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#

use DBI;
use Socket;
use POSIX;
use MIME::Base64;
use perl_functions;

# list DBI's available drivers

@dbi_driver_names = DBI->available_drivers;

# check to see if we have the 'mysql' driver for the DBI object installed

$mysql_driver = 0;

foreach(@dbi_driver_names)
{
    $mysql_driver = 1 if $_ eq 'mysql';
}

# if $mysql_driver is still set to 0 after this loop, then the driver wasn't found, and we can't
# continue

die "The mysql driver for the perl DBI object was not found. Perhaps the DBD::mysql perl module hasn't been fully installed? " unless $mysql_driver == 1;

# set the $ETX, $EOT, $NAK and $CAN variables to thier respective bytes

my $ETX = chr(3); # end of text
my $EOT = chr(4); # end of transmission
my $NAK = chr(21); # negative acknowledge
my $CAN = chr(24); # cancel

# define our socket to listen to

my $socket = $CONF{'RC_ROOT'} . '/var/rc.sock';

# do some system stuff with the socket

my $uaddr = sockaddr_un($socket);

# create the socket as a UNIX domain socket

socket(SERVER,PF_UNIX,SOCK_STREAM,0) || die "socket: $!";

# turn on autoflush for STDOUT

$| = 1;

#

unlink($socket);

# bind this process to the socket 

bind (SERVER, $uaddr) || die "bind: $!";

# change the ownership and permissions on the socket so that only the ravencore webserver can
# read / write to it. It's VERY important that these permissions are set BEFORE we start to
# listen to the socket

$rcadmin = "rcadmin";

# chown only accepts numeric uid/gids, so get the $uid of rcadmin here

$uid  = getpwnam($rcadmin);

# group ownership set to root

chown $uid, 0, $socket;

# very strict file permissions on the socket

chmod 0600, $socket;

# begin to listen to the socket

listen(SERVER,5) || die "listen: $!";

# "daemonize" ourself by forking, and exiting if we're the parent. The child process will then
# proceed to start a new session. We do this so that when we're started from the shell, we aren't
# attached to the session that started us. If there is a fatal error before this point, the $?
# error code will be set to non-zero, and we'll know there was something wrong

defined(my $ppid = fork) or die "Can't fork: $!";
exit if $ppid;
setsid or die "Can't start a new session: $!";

# before we enter our loop, define this signal to catch children processes' exit signals with
# the REAPER function

$SIG{CHLD} = \&REAPER;

#
# TODO: Handle other signals here for clean restart / shutdown
#

#
# TODO: Write our $$ (pid) to a file
#       IF the pid file already exists, read it first and kill the process
#

# endlessly loop, waiting for a connection

for ( $waitedpid = 0; accept(CLIENT,SERVER) || $waitedpid; $waitedpid = 0, close CLIENT)
{

# if $waitedpid still exists, then we're not ready to do the below, so skip

    next if $waitedpid;

# past this point, we have a connection from a client. fork into parent/child processes to handle the request
    
    my $pid;

    if (!defined($pid = fork))
    {
# fatal error in fork()... there's something very bad happening with the system. usually out of memory

# explicity tell &fatal_error not to exit, as we're not nessisarilly dead in the water. we might be able
# to fork next time the server is called, so don't just die. This is probably the only time we should
# set $noexit with a fatal_error call
	$noexit = 1;

	&fatal_error("cannot fork: $!");

# unset the noexit
	$noexit = 0;

# go to the beginning of the loop so we can try again....
	next;

    }
    elsif ($pid)
    {
# i'm the parent... go back and wait for another connection

	next;

    }
# i'm the child... handle the data request
# NOTE: any values changed past this point won't affect the parent process at all, since all of our
# variables are copies of the originals

# redirect anything printed to STDERR to instead call the &do_error function
    $stderr = tie *STDERR, 'Redirect', \&do_error;

# turn on autoflush on the CLIENT I/O handle, so output we send via print statements goes right away

    select CLIENT;
    $| = 1;
    select STDOUT;

# unset our GOT_CONF variable so our bash script we run will get all their settings

    $ENV{'GOT_CONF'} = ''; 

# read in our database password. currently we have to do this each time we connect, because the password
# might have changed since we first started, and a child process can't change a variable and have the
# parent process know about it

    $passwd = &get_passwd;
    
# connect to the database

    my $db = DBI->connect('DBI:mysql:database='.$CONF{'MYSQL_ADMIN_DB'}.
			  ';host='.$CONF{'MYSQL_ADMIN_HOST'}.
			  ';port='.$CONF{'MYSQL_ADMIN_PORT'},
			  $CONF{'MYSQL_ADMIN_USER'}, $passwd, {RaiseError => 0});

# cache our "initial_passwd" response, since we have our $passwd in memory right now
    if($passwd =~ m/^ravencore$/i) { $initial_passwd = "true" }
    else { $initial_passwd = "false" }

    &destroy(\$passwd);

# read in the data from the client.... usually an SQL statement
# we're in a while loop because we want to handle as many requests as is nessisary

    while($query = &data_read(CLIENT))
    {
	
# unset our data variable before we begin

	$data = '';

#
# TODO: implement query logging. part of the whole reason why everything talks to the socket for data
# queries and such, is so that there is a central point of logging... set different logging verbose levels,
# so we'll know whather to report just insert/update/delete queries, just report commands, or report
# ALL queries, directed to a logfile somewhere
#

# check what kind of input this is
	
	if($query =~ m/^auth /i)
	{

# set $pw equal to $query and then remove the "auth " part from the beginning, so you have just the password
	    
	    $pw = $query;
	    $pw =~ s/^auth //i;

# compare $pw to the &get_passwd ( which comes from the .shadow file ). return "true" on success and
# "false" on failure

	    if($pw eq &get_passwd)
	    {
		$data = "true";
	    }
	    else
	    {
		$data = "false";
	    }
	    
	}
	elsif($query =~ m/^connect/i)
	{
# we're being asked if we have a database connection
	    if( $db )
	    {
		$data = "true";
	    }
	    else
	    {
		$data = "false";
	    }

	}
	elsif($query =~ m/^initial_passwd/i)
	{
# we're being asked if our password has been set. right now, this means it is set to "ravencore"
# this is cached from before we started our loop

	    $data = $initial_passwd;

	}
	elsif($query =~ m/^service_running /i)
	{
# is the given service running?
# TODO: make this perl code, instead of having to call an external script
            $service = $query;
            $service =~ s/^service_running //i;
	    
	    open RUN, $CONF{'RC_ROOT'} . '/bin/is_service_running ' . $service;
	    $data = <RUN>;
	    close RUN;

	    chomp($data);

	}
	elsif($query =~ m/^run /i)
	{

# make the $cmd variable contain the command to be run, by removing the "run " from the beginning
	 
	    $cmd = $query;
	    $cmd =~ s/^run //i;
   
#
# do some checking on $cmd here. basically disallow anything that could trick the shell
# into running something it shouldn't
#

	    if(
	       $cmd =~ m/\.\./ or
	       $cmd =~ m/;/ or
	       $cmd =~ m/&/ or
	       $cmd =~ m/\$/ or
	       $cmd =~ m/\`/ or
	       $cmd =~ m/>/ or
	       $cmd =~ m/</ or
	       $cmd =~ m/\|/ or
	       $cmd =~ m/\n/
	       )
	    {

		&do_error('Unsafe command: ' . $cmd);

	    }
	    else
	    {
		
		@args = split/ /, $cmd;
		
# get information about the command to run
		($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat $CONF{'RC_ROOT'} . '/bin/' . $args[0];

# fix the mode into "readable" permissions
		$mode = sprintf "%04o", $mode & 07777;

		if( ! -f $CONF{'RC_ROOT'} . '/bin/' . $args[0] )
		{
# make sure the command exists in the first place
		    &do_error('Unable to execute ' . $args[0] . ' : File does not exist');
		}
		elsif($uid != 0)
		{
# must be owned by root
		    &do_error('Unable to execute ' . $args[0] . ' : Not owned by root');
		}
		elsif($gid != 0)
		{
# must not be in any other group
		    &do_error('Unable to execute ' . $args[0] . ' : Not in the root system group');
		}
		elsif($mode ne "0500")
		{
# strict file permissions
		    &do_error('Unable to execute ' . $args[0] . ' : Incorrect permissions. Must be set to 0500');
		}
		else
		{
		    
# run it
		    
		    open CMD, $CONF{'RC_ROOT'} . '/bin/' . $cmd . '|';
		    
		    @output = <CMD>;
		    
		    close CMD;
		    
# only print output if it exists
		    
		    if( "@output" ) {
			
# turn the array into a string
			
			foreach (@output) { $data .= $_; }
			
# base64 encode the output, just in case it contains funny characters....
			
			$data = encode_base64($data);
			
		    }
		
		}

	    }
		
	}
	else
	{

# if we get here, we're to run an SQL query
# check to see if we have a database connection, and if not, issue an error and skip

	    if( ! $db )
	    {

		&do_error("No database connection");
		
		print CLIENT $EOT;

		next;
		
	    }

# set some values to zero
	    
	    $rows_affected = 0;
	    $insert_id = 0;

# if this query is to change the password, do it here
	    if($query =~ m/^passwd /i)
	    {
# parse out the info from the $query. the @xxx array catches any remaining elements if any
		($x, $old, $new, @xxx) = split / /,$query;
		
		if($old eq &get_passwd)
		{
		    
		    $db->do("SET PASSWORD FOR '" . $CONF{'MYSQL_ADMIN_USER'} . "'\@'" . $CONF{'MYSQL_ADMIN_HOST'} . "' = PASSWORD('" . $new . "')");
		    
		    if( ! $db->errstr )
		    {
# the password change was successful. commit the password to the .shadow file and return true
			open PASSWD, ">" . $CONF{'RC_ROOT'} . "/.shadow";
			print PASSWD $new . "\n";
			close PASSWD;
			
			$data = "true";

		    }
		    
		}
		else
		{
		    $data = "false";
		}
		
	    }
# do the sql query, but the kind of query depends on what we do.
# if it's NOT a "select" or a "show" query (do a case in-sensative match) then we simply "do"
# the query and get the $rows_affected and $insert_id data
	    elsif($query !~ m/^select/i and $query !~ m/^show/i)
	    {
		
		$rows_affected = $db->do($query);
		
		if ( ! $db->errstr )
		{

		    $insert_id = $db->{ q{mysql_insertid}};

# this isn't a select statement, but we still return data in the same format

		    $data = $insert_id . $ETX . $ETX . $rows_affected . $ETX . $ETX;
		}
		
	    }
	    else
	    {
		
# on "select" queries, we're a little more involved... need to return the data we got :)
		
		$result = $db->prepare($query);
		
		$result->execute();
		
		if ( ! $db->errstr )
		{
		    
# fetch the data into a hash. That way, we have both the column name and the value
		    while( $hash_ref = $result->fetchrow_hashref() )
		    {
			
# data is in the following format:
# name{value} (value is base64 encoded) followed by an ETX character (end of text)
			foreach (keys %$hash_ref)
			{
			    $data .= $_ .'{' . encode_base64($hash_ref->{$_}) . '}' . $ETX;
			}
			
# end the string with a ETX character... end of string will always be two ETX's
# unless there is no results, in which case, it doesn't matter
			
			$data .= $ETX;
			
		    }
		    
		    $result->finish();
		    
# gather our info. the PHP data_query will know how to parse this.
		
		    $data = $insert_id . $ETX . $ETX . $rows_affected . $ETX . $ETX . $data;

		}

	    }

	}
	
# print the $data to the client along with a EOT character at the end, noting the end-of-data
	
	print CLIENT $data . $EOT;
	
    } # end while($query = &data_read(CLIENT))

# force the socket to close
    
    close CLIENT;
    
# exit cleanly

    POSIX::_exit 0;

}


# function to clean up zombies

sub REAPER
{
    $SIG{CHLD} = \&REAPER;
    $waitedpid = wait;
# TODO: once query logging is written, have it be prepended and appended with the child $pid
# and the eventual exit code of the process
#    print "reaped $waitedpid" . ($? ? " with exit $?" : '') . "\n";
}

# read in a line of data. don't be fooled by the word "line", as it doesn't stop at a newline character, but
# rather at an end-of-transmission character. the built in < > perl operators read until a newline character,
# so we have to go about reading a different way

sub data_read
{

# our first and only argument is the filehandle in which to read

    my $h = shift;

# initilize some local variables so they don't conflict with the rest of the script

    my $data;
    my $c;

# $data .= $c; comes FIRST so that $data doesn't contain the $EOT character at the end
# then we read in one byte, and get the return value of the read syscall
# if the $ret is zero, then nothing was read. return with zero, or "false", so the program exists the loop
# and forces the client connection to close.

    do {

	$data .= $c;

	$ret = read $h, $c, 1;

	if ( $ret == 0 ) { return 0; }

    } while ( $c ne $EOT );

# this is all done while the character read isn't an EOT (end-of-transmission) character. all input on the
# socket up until the $EOT character will be base64 encoded, so decode it here as we return it

    return decode_base64($data);

}

# function that is called inside the child process, to handle error messages

sub do_error
{
    my $errstr = "@_";

    print CLIENT $NAK . $errstr;
}

# function that is called if things have gone horribly wrong. Print all the appropriate
# closing bytes to the client ( NAK for error, CAN for fatal error, and EOT so the client
# knows we're done reporting ), and exit out with an error.

sub fatal_error
{
    my $errstr = "@_";

    print CLIENT $NAK . $errstr . $CAN . $EOT;

    close CLIENT;

# if $noexit is set, then don't exit. otherwise, default behavior is to exit

    POSIX::_exit 1 unless $noexit == 1;
    
}

# create our internal error redirection object
# we can have this at the bottom of this code because the perl preprocessor loads it
# before script execution

package Redirect;

sub TIEHANDLE
{
    my ($class, $in) = @_;
    my $filehandle = $in;
    bless $filehandle, $class;
}

sub PRINT
{
    my $filehandle = shift;
    $filehandle->(@_);
}

# end this object
1;
