#!/bin/bash
#
#                  RavenCore Hosting Control Panel
#                Copyright (C) 2005  Corey Henderson
#
#     This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#

# this is the %post script for ravencore rpm

export GOT_CONF=1

. /etc/ravencore.conf || exit 1

# define some of our connect variables
    
MYSQL_ADMIN_HOST=localhost
MYSQL_ADMIN_DB=ravencore
CONNECT=0
NEW_MYSQL_ADMIN_USER="admin"
NEW_MYSQL_ADMIN_PASS="ravencore"

echo "Attempting to gain access to mysqld and install the ravencore database"
sleep 1

# start mysqld if it isn't running

if [ -z "$(pidof mysqld)" ]; then

    echo "mysqld not running, attemping to start...."
    
    if [ -f $INITD/$mysql_service ]; then

	$INITD/$mysql_service start

    else

	echo "Unable to find the mysql init script. the mysql server may not be installed"

	exit 1

    fi

fi

# load the database.cfg file

echo -n "trying to connect with database.cfg file...."

. $RC_ROOT/database.cfg 2> /dev/null

if [ $? -ne 0 ]; then

# failed to load the database.cfg file, it probably doesn't exist
	
	CONNECT=0
	
	echo "failed"

else
    
# make sure we have the MYSQL_ADMIN variables
    
    if [ ! -z "$MYSQL_ADMIN_PASS" ] && [ ! -z "$MYSQL_ADMIN_USER" ]; then
	
# attempt DB connection
	
	mysql -u $MYSQL_ADMIN_USER -p$MYSQL_ADMIN_PASS -e "" 2> /dev/null
	
	if [ $? -eq 0 ]; then
	    
# success
	    CONNECT=1
	    echo "ok"

	else
	    
# failure
	    CONNECT=0
	    echo "failed"

	fi
	
    else
	
# no MYSQL_ADMIN variables, no connection
	
	CONNECT=0
	echo "failed"

    fi
    
fi


if [ $CONNECT -eq 0 ]; then
    
# no conection, so we attempt blank password root mysql connection

    echo -n "trying to connect with a blank password...."
    
    mysql -u root -e "" 2> /dev/null
    
    if [ $? -eq 0 ]; then
	
# we cot a connection with the blank user

	CONNECT=1
	MYSQL_ADMIN_USER="root"
	MYSQL_ADMIN_PASS=""

	echo "ok"
	
    else

	CONNECT=0
	echo "failed"

    fi

fi

if [ $CONNECT -eq 0 ]; then

# attempt connection with our standard setup user / pass

    echo -n "trying to connect with $NEW_MYSQL_ADMIN_USER / $NEW_MYSQL_ADMIN_PASS...."

    mysql -u $NEW_MYSQL_ADMIN_USER -p$NEW_MYSQL_ADMIN_PASS -e "" 2> /dev/null
    
    if [ $? -eq 0 ]; then

	CONNECT=1

	MYSQL_ADMIN_USER=$NEW_MYSQL_ADMIN_USER
	MYSQL_ADMIN_PASS=$NEW_MYSQL_ADMIN_PASS
	
	echo "ok"

    else
	
	CONNECT=0
	echo "failed"

    fi

fi

if [ $CONNECT -eq 0 ]; then

# we are getting pretty desparate to connect here. Attempt to hack our way into mysqld

# stop mysqld
    
    echo "trying to force mysqld to startup with no-auth....stopping mysqld"

    $INITD/$mysql_service stop
    
    sleep 3

# determine where the mysql safe script is
    
    if [ -x /usr/bin/safe_mysqld ]; then

	safe_mysqld="/usr/bin/safe_mysqld"

    fi
    
    if [ -x /usr/bin/mysqld_safe ]; then
	
	safe_mysqld="/usr/bin/mysqld_safe"
	
    fi

    if [ -z "$safe_mysqld" ]; then

	echo "Unable to find the path to the safe mysqld init script. Unable to continue"

	exit 1

    fi
    
# start the mysqld server with our own intentions
    
    echo "starting mysqld with --skip-grant-tables...."

    $safe_mysqld --user=mysql --socket=/var/lib/mysql/mysql.sock --pid-file=/var/run/mysqld/mysqld.pid --datadir=/var/lib/mysql --skip-grant-tables --skip-networking &> /dev/null &

# give the mysqld server some time to start up
    
    sleep 3
    
# tell the server to set the root password to something we know.

# different mysql versions can have different privelege columns. This loop will figure them out and
# build our insert statement to generate a user with full mysqld access
	for priv in $(mysql mysql -e "desc user" | sed '1d' | awk "/enum\('N','Y'\)/ {print \$1}"); do

	    privs_str="$privs_str $priv = 'Y',"

	done

# figure out if the $NEW_MYSQL_ADMIN_USER exists

    admin_user_exists=$(mysql mysql -e "select count(*) from user where User = '$NEW_MYSQL_ADMIN_USER'" | sed '1d')
    
    if [ $admin_user_exists -gt 0 ]; then

	echo "user $NEW_MYSQL_ADMIN_USER found. attempting to update the password to \"$NEW_MYSQL_ADMIN_PASS\"...."

# update this user's password, as well as all the privilieges of the user
#	mysqladmin -u $user flush-privileges password "$NEW_MYSQL_ADMIN_PASS" &> /dev/null
	mysql mysql -e "update user set $privs_str Password = password('$NEW_MYSQL_ADMIN_PASS') where User = '$NEW_MYSQL_ADMIN_USER';flush privileges"

# tell us that we reset their admin password
	reset_password=1

    else
	
# attempt to insert a full privileged user into the database

	echo "user \"$NEW_MYSQL_ADMIN_USER\" not found for mysqld. attemping to create it...."

# add the host, username, and password to the statement
	sql="insert into user set $privs_str Host = 'localhost', User = '$NEW_MYSQL_ADMIN_USER', Password = password('$NEW_MYSQL_ADMIN_PASS')"

# insert the user and flush the privileges
	mysql mysql -e "$sql;flush privileges"

    fi

    sleep 1

# now we should restart mysqld so it's running normally

    echo "attempting to restart the mysqld server...."
    
    $INITD/$mysql_service stop

# wait a few seconds before we start, just to be safe
    sleep 3
    
    $INITD/$mysql_service start

    sleep 3

    echo -n "now lets try our new connect information...."
    
# re-attempt the database connection
    mysql -u $NEW_MYSQL_ADMIN_USER -p$NEW_MYSQL_ADMIN_PASS -e "select now()" &> /dev/null

    if [ $? -eq 0 ]; then
	
	CONNECT=1
	MYSQL_ADMIN_USER=$NEW_MYSQL_ADMIN_USER
	MYSQL_ADMIN_PASS=$NEW_MYSQL_ADMIN_PASS
	echo "ok"
	
    else

	CONNECT=0
	echo "failed"
	
    fi
    
fi

if [ $CONNECT -eq 0 ]; then

# failed to get any connection. We cannot continue

    echo "Could not connect to MySQL server. Please setup a MySQL user 'admin' with password '$NEW_MYSQL_ADMIN_PASS' that has full administrative access, and run this script again"

    exit 1

fi

MYSQL_STR="mysql -u $MYSQL_ADMIN_USER"

# if we have a mysql password, we're good to go

if [ -n "$MYSQL_ADMIN_PASS" ]; then

    MYSQL_STR="$MYSQL_STR -p$MYSQL_ADMIN_PASS"

else

# we have a blank password, need to create our admin user and remove the blank password user(s)

    MYSQL_ADMIN_USER=$NEW_MYSQL_ADMIN_USER
    MYSQL_ADMIN_PASS=$NEW_MYSQL_ADMIN_PASS

    echo "creating user \"$NEW_MYSQL_ADMIN_USER\" for mysqld...."

    $MYSQL_STR -e "grant all privileges on *.* to $MYSQL_ADMIN_USER@$MYSQL_ADMIN_HOST identified by '$MYSQL_ADMIN_PASS' with grant option"

# remove blank password users

    echo "removing mysql users with a blank password, if they exist...."

    $MYSQL_STR mysql -e "delete from user where Password = ''"

#

    $MYSQL_STR -e "flush privileges"

# resest MYSQL_STR with new user

    MYSQL_STR="mysql -u $MYSQL_ADMIN_USER -p$MYSQL_ADMIN_PASS"

fi

# check to see if the database exists

echo -n "checking to see if $MYSQL_ADMIN_DB database exists...."

$MYSQL_STR -e "use $MYSQL_ADMIN_DB" 2> /dev/null

if [ $? -ne 0 ]; then

# database doesn't exist, attempt to create it

    echo "no"

    echo "attempting to create it...."

    $MYSQL_STR -e "create database $MYSQL_ADMIN_DB" 2> /dev/null
    
    if [ $? -ne 0 ]; then
	
# unable to create database, we probably don't have permission to
	
	echo "Unable to create database $MYSQL_ADMIN_DB, we probably don't have the appropriate permissions set. Please make sure $MYSQL_ADMIN_USER can create a database, and run this script again"
	
	exit 1
	
    fi
    
# now we attempt to load the sql tables
    
    echo -n "attempting to load the data structure...."

    for table in `ls $RC_ROOT/etc/sql_tables | sed 's/\.sql$//'`; do

	$MYSQL_STR $MYSQL_ADMIN_DB < $RC_ROOT/etc/sql_tables/$table.sql

    done

    echo "done"

else

# if we get here, the database already exists...

    echo  "yes"

# check the database integrety by matching all the tables

    echo "checking database integrity"

# cache our table info

    table_info=$($MYSQL_STR $MYSQL_ADMIN_DB -e "show tables" | sed '1d')

    for table in `ls $RC_ROOT/etc/sql_tables | sed 's/\.sql$//'`; do

# reset our variable of whether to show a dot
	show_dot=1

# check to see if we have this table by looping through $table_info and checking each one

	$MYSQL_STR $MYSQL_ADMIN_DB -e "show tables" | sed '1d' | grep $table &> /dev/null

# didn't find the table

	if [ $? -ne 0 ]; then

# load the new table

	    echo -n "found new table \"$table\". loading it into the database...."

	    $MYSQL_STR $MYSQL_ADMIN_DB < $RC_ROOT/etc/sql_tables/$table.sql

	    echo "ok"
	    
	    show_dot=0

	else

# check to see if the table differs from what we have in the database
# the table .sql files were dumped with command:
# mysqldump -d --opt -u $MYSQL_ADMIN_USER -p$MYSQL_ADMIN_PASS $MYSQL_ADMIN_DB $table | grep ' ' | grep -v '^--'

	    mysqldump -d --opt -u $MYSQL_ADMIN_USER -p$MYSQL_ADMIN_PASS $MYSQL_ADMIN_DB $table | grep '^ ' | sed 's/`//g' > $RC_ROOT/var/tmp/diff.$$

	    new_columns=$(cat $RC_ROOT/etc/sql_tables/$table.sql | grep '^ ' | sed 's/`//g' | diff $RC_ROOT/var/tmp/diff.$$ - | grep '^>')
	    custom_columns=$(cat $RC_ROOT/etc/sql_tables/$table.sql | grep '^ ' | sed 's/`//g' | diff $RC_ROOT/var/tmp/diff.$$ - | grep '^<' | sed 's/<//')
	    
# if the table structures differ ( new columns in the .sql file )
	    
	    if [ -n "$new_columns" ]; then
		
		echo -n "found new column data in table $table, saving table row information...."

		show_dow=0

# dump the table data
		
		mysqldump --add-locks --all -c --quick --lock-tables -t -u $MYSQL_ADMIN_USER -p$MYSQL_ADMIN_PASS $MYSQL_ADMIN_DB $table > $RC_ROOT/var/tmp/$table.$$.data.sql
		
		mysqldump --opt -d -u $MYSQL_ADMIN_USER -p$MYSQL_ADMIN_PASS $MYSQL_ADMIN_DB $table > $RC_ROOT/var/tmp/$table.$$.struct.sql
		
		echo "ok"
		echo -n "loading new table structure...."
		
# load the new table structure
		
		$MYSQL_STR $MYSQL_ADMIN_DB < $RC_ROOT/etc/sql_tables/$table.sql
		
		echo "ok"

# check to see if they made any additions to the table before the upgrade

		if [ -n "$custom_columns" ]; then

		    echo "custom database columns found in old table structure...."

		    echo -n "attempting to re-add them...."

# cache the table definition

		    table_info=$($MYSQL_STR $MYSQL_ADMIN_DB -e "desc $table" | sed '1d')

# attempt to add them back

	       	    cat $RC_ROOT/etc/sql_tables/$table.sql | grep '^ ' | sed 's/`//g' | diff $RC_ROOT/var/tmp/diff.$$ - | grep '^<' | sed 's/<//' | sed 's/,$//g' | while read line; do

# if this line is not blank

			if [ -n "$line" ]; then

# first item on the line is the column name
			    
			    column=$(echo $line | awk '{print $1}')
			    
# check to see if this column doesn't already exist
			    found=0
			    for i in $table_info; do
				[ "$column" = "$i" ] && found=1
			    done
			    
# if the column is not found, attempt to add it back
			    
			    [ $found -eq 0 ] && $MYSQL_STR $MYSQL_ADMIN_DB -e "alter table $table add column $line"
			
			fi
    
		    done

		    echo "done"

		fi


		echo -n "reloading dumped data in the the new table...."
# load the dumped data back into the table
		
		$MYSQL_STR $MYSQL_ADMIN_DB < $RC_ROOT/var/tmp/$table.$$.data.sql
		
# if we didn't get an error, go ahead and remove the data files in var/tmp/
		
		if [ $? -eq 0 ]; then
		    
		    rm -f $RC_ROOT/var/tmp/$table.$$.data.sql
		    rm -f $RC_ROOT/var/tmp/$table.$$.struct.sql
		    
		else
		    
		    echo "********"
		    echo "* ERROR: import of data from table $table failed."
		    echo "*        Please reference backup files stored in:"
		    echo "******** $RC_ROOT/var/tmp/$table.$$.data.sql"
		    echo "******** and $RC_ROOT/var/tmp/$table.$$.struct.sql"
		    echo "********"
		    
		fi

		echo "ok"

	    fi

	    rm -f $RC_ROOT/var/tmp/diff.$$
	    
	fi # end if, did we find this $table

	[ $show_dot -eq 1 ] && echo -n "."

    done
    
    echo
    echo "database integrity check complete"

fi

# write database.cfg and .shadow files

echo "writting connect info to $RC_ROOT/database.cfg"

cat <<EOF > $RC_ROOT/database.cfg
MYSQL_ADMIN_HOST="$MYSQL_ADMIN_HOST"
MYSQL_ADMIN_USER="$MYSQL_ADMIN_USER"
MYSQL_ADMIN_DB="$MYSQL_ADMIN_DB"
EOF

echo $MYSQL_ADMIN_PASS > $RC_ROOT/.shadow

chown rcadmin:root $RC_ROOT/.shadow $RC_ROOT/database.cfg
chmod 600 $RC_ROOT/.shadow
chmod 400 $RC_ROOT/database.cfg

echo "Success!!"

if [ -n "$reset_password" ]; then

    echo "**********"
    echo "** NOTE ** We had to reset the $MYSQL_ADMIN_USER password to \"$MYSQL_ADMIN_PASS\" "
    echo "**********"

fi

# tell us that we ran the db_install script
touch $RC_ROOT/var/run/db_install

exit 0
