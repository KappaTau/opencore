#!/usr/bin/perl
#
#                  RavenCore Hosting Control Panel
#                Copyright (C) 2005  Corey Henderson
#
#     This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#

$RC_ROOT = ( $ENV{'RC_ROOT'} ? $ENV{'RC_ROOT'} : '/usr/local/ravencore' );

#

if( $ARGV[0] eq "rcserver" )
{
    chdir $RC_ROOT . '/var/lib';
    
    exec $RC_ROOT . '/sbin/rcserver';
}

# add the ravencore lib directory to the search path for perl modules
unshift @INC, $RC_ROOT . '/var/lib';

# we require, instead of use, because "use" is pre-processed and we don't get a chance to look in our
# RC_ROOT/var/lib directory.
require rcclient;

$rc = new rcclient($RC_ROOT);

# build our $cmd off of everything given on the command line

foreach (@ARGV)
{
    $cmd .= $_ . ' ';
}

#
chop $cmd;

# user-friendly wrapper for the "passwd" command

if( $cmd eq "passwd" )
{
    $| = 1;

    my $error;

# nested do/while loop, allowing the user to retype the password if they made a mistake, w/o having
# to re-run the script
    do
    {
	
	$error = 0;
	my $passwd = "";
	my $passwd_again = "";
	
	print "Enter in a new password: ";
	
	$passwd = &passwd_prompt;
	
	print "\n";
	
# confirm password
	print "  Re-enter the password: ";

	$passwd_again = &passwd_prompt;
	
	print "\n";
	
	if( $passwd ne $passwd_again )
	{
	    print "The passwords must match!\n\n";
	    $error = 1;
	}

	if( $error == 0 )
	{
	    $error = 1;
	    $error = 0 if $rc->passwd($rc->get_passwd . ' ' . $passwd);
	}

    } while( $error );

    print "Success!!\n";
    
    exit;
    
}

# run the command
# any output of the command will be printed

my $ret = $rc->do_raw_query($cmd);

my $dat = &print_r($ret);

print $dat . "\n" if $dat;

# global variable for the print_r function
$nest = 0;

# look at the given variable, print it if it's string, and if it's a hash, walk down the hash and call
# itself again on those values... effectivly giving a similiar functionality to the PHP print_r function

sub print_r
{
    my $val = shift;

    my $data;
    
    if( ref($val) eq "HASH" )
    {
	$nest++;
	$data .= "\%HASH\n" . &x_t($nest-1). "[\n";

	foreach my $b (keys %$val)
	{
	    $data .= &x_t($nest);

	    $data .= $b . "=" . &print_r($val->{$b}) . "\n";
	}
	
	$data .= &x_t($nest-1) . "]\n";

	$nest--;
    }
    else
    {
	$data = $val;
    }
    
    return $data;
}

# return X "\t" characters

sub x_t
{
    my $x = shift;
    
    my $str;

    for(my $i = 0; $i < ($x); $i++)
    {
	$str .= "\t";
    }

    return $str;
}


# a password prompt

sub passwd_prompt
{

    my $passwd;
    my $n = 0;

    my $_DEL = chr(127);
    my $_BS = chr(8);

    $| = 1;

    system "stty", '-echo', '-icanon', 'eol', "\001";

    while( my $c = getc )
    {
        last if $c eq "\n";

        if( $c ne $_DEL )
        {
            print "*";
	    $passwd .= $c;
            $n++;
        }

        if( $c eq $_DEL and $n > 0)
        {
            print $_BS . " " . $_BS;
	    chop $passwd;
            $n--;
        }

    }

    system "stty", 'echo', 'icanon', 'eol', '^@';

    return $passwd;

}
