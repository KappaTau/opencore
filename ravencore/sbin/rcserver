#!/usr/bin/perl
#
#                  RavenCore Hosting Control Panel
#                Copyright (C) 2005  Corey Henderson
#
#     This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#

use Socket;
use POSIX;
use ravencore;

# name our process
$0 = 'rcserver';

#

$rc = new ravencore;

# define our socket to listen to

my $socket = $rc->{CONF}{RC_ROOT} . '/var/rc.sock';
$rc->debug("socket set to " . $socket);

# do some system stuff with the socket

my $uaddr = sockaddr_un($socket);

# create the socket as a UNIX domain socket

socket(SERVER,PF_UNIX,SOCK_STREAM,0) || die "socket: $!";

# turn on autoflush for STDOUT

$| = 1;

# remove the socket if it was there before

unlink($socket);

# bind this process to the socket 

bind (SERVER, $uaddr) || die "bind: $!";
$rc->debug("bound to socket " . $socket);

# change the ownership and permissions on the socket so that only the ravencore webserver can
# read / write to it. It's VERY important that these permissions are set BEFORE we start to
# listen to the socket

$rcadmin = "rcadmin";

# chown only accepts numeric uid/gids, so get the $uid of rcadmin here

$uid = getpwnam($rcadmin);

# group ownership set to root

chown $uid, 0, $socket;

# very strict file permissions on the socket

chmod 0600, $socket;

# begin to listen to the socket

listen(SERVER,5) || die "listen: $!";

#
# run all the checks needed to get the web server running for our control panel front-end.
# we do it after we listen to the socket so a client that connects right after the webserver
# starts won't get a "connection refused" message from the PHP interface, but we do this before
# we "daemonize" so that if there is a problem starting up, we haven't detached from the
# sysadmin's terminal yet, and can error out appropriatly.
#

# TODO: check to see if mysql server is running. if not, setart it

# start the control paenl webserver

$rc->start_webserver;

# "daemonize" ourself by forking, and exiting if we're the parent. The child process will then
# proceed to start a new session. We do this so that when we're started from the shell, we aren't
# attached to the session that started us. If there is a fatal error before this point, the $?
# error code will be set to non-zero, and we'll know there was something wrong

defined(my $ppid = fork) or die "Can't fork: $!";
exit if $ppid;
setsid or die "Can't start a new session: $!";

# TODO: close our STDIN filehandle, and redirect STDOUT/STDERR to a log file somewhere

$rc->debug("Proccess detatched from terminal");

# before we enter our loop, define this signal to catch children processes' exit signals with
# the REAPER function

$SIG{CHLD} = \&REAPER;
$SIG{__WARN__} = \&send_error;
$SIG{__DIE__} = \&send_error;

# signal used to shutdown
$SIG{TERM} = \&sig_TERM;

#
# TODO: Handle other signals here for clean restart / shutdown
#

#
# TODO: Write our $$ (pid) to a file
#       IF the pid file already exists, read it first and kill the process
#

my %child;

# endlessly loop, waiting for a connection

for ( $waitedpid = 0; accept($rc->{CLIENT},SERVER) || $waitedpid; $waitedpid = 0, close $rc->{CLIENT})
{

# if $waitedpid still exists, then we're not ready to do the below, so skip

    next if $waitedpid;

    $rc->debug("client connected");

# past this point, we have a connection from a client. fork into parent/child processes to handle the request

# limit connections to MAX_CLIENT_CONNECTION, and if exceeded, close the connection with an error here
# this is to prevent a DOSS attack, filling up the process tree and using system resources

# count the number of active connections

    my $c = 0;

    foreach my $id (keys %child)
    {
	$c++;
    }

    if($c > $rc->{CONF}{MAX_CLIENT_CONNECTION})
    {

	$rc->debug("connection refused, too many connections");

# in order to issue the error, we first have to read what the client put. just don't do anything with it
	$rc->data_read;

# issue the error
	$rc->do_error("Too many connections, try again later.");

# close the connection and wait for the next one, hopefully some will have disconnected by then
	close $rc->{CLIENT};

	next;
    }

    my $pid;

    if (!defined($pid = fork))
    {
# fatal error in fork()... there's something very bad happening with the system. usually out of memory
	
# explicity tell fatal_error not to exit, as we're not nessisarilly dead in the water. we might be able
# to fork next time the server is called, so don't just die. This is probably the only time we should
# set $noexit with a fatal_error call
	$rc->{noexit} = 1;
	
	$rc->fatal_error("cannot fork: $!");
	
# unset the noexit
	$rc->{noexit} = 0;

# go to the beginning of the loop so we can try again....
	next;

    }
    elsif ($pid)
    {
# i'm the parent... go back and wait for another connection

	$child{$pid} = 1;
	
	next;
	
    }
# i'm the child... handle the data request
# NOTE: any values changed past this point won't affect the parent process at all, since all of our
# variables are copies of the originals

# rename the process
    $0 = 'rcserver (child)';

    $rc->debug("child process spawned");
    
# redirect anything printed to STDERR to instead call the do_error function
#    $stderr = tie *STDERR, 'Redirect', \$rc->do_error;

# TODO: determine if we need to likewise do the above for STDOUT, and whether or not we should close
# the STDIN handler

# turn on autoflush on the CLIENT I/O handle, so output we send via print statements goes right away

    select $rc->{CLIENT};
    $| = 1;
    select STDOUT;

# get a database connection
    $rc->database_connect;
    
# Ideally we'd get a database connection on startup and pass a shared connection to the child processes,
# instead of make a db connection for each client connection. But this is problematic when passwords change,
# mysql server restarts, or any other reason why the connection would be broken, we'd end up passing a dead
# shared connection. Perhaps if I could figure out how to check to see if given connection is still alive
# ( maybe via mysql_ping ? ) as the client connects, and reconnect to the database if the connection is
# dead, it'll work.

# read in database variables
    my %dbc = $rc->get_db_conf;
    
    foreach my $key (keys %dbc)
    {
	$rc->{CONF}{$key} = $dbc{$key};
    }

# read in the data from the client in a while loop, we want to handle as many requests as is nessisary
# TODO: implement a timeout on the data_read, so if the client takes too long to send anything, they are
# disconnected
    
    while( $query = $rc->data_read )
    {
	
# call the function from the ravencore object
	my $data = $rc->client_request($query);
	
# print the $data to the client along with a EOT character at the end, noteing the end-of-data
	print {$rc->{CLIENT}} $data . $rc->{EOT};
	
    } # end while($query = $rc->data_read)
    
# TODO: call a destroy function for ravencore, to close any open files there may be

# force the socket to close    
    close $rc->{CLIENT};
    
# exit cleanly
    POSIX::_exit(0);

}

# stuff to do on shutdown

sub sig_TERM
{
    $rc->debug("Receiving sig TERM, shutting down");

# kill the apache for ravencore
    system('killall -15 ravencore.httpd 2> /dev/null');

    exit(0);
}

#

sub send_error
{
    my $msg = "@_";

    print { $rc->{CLIENT} } $msg;
}

# function to clean up zombies

sub REAPER
{
    $SIG{CHLD} = \&REAPER;
    $waitedpid = wait;

    delete $child{$waitedpid};

    $rc->debug("child pid $waitedpid disconnected");

# TODO: once query logging is written, have it be prepended and appended with the child $pid
# and the eventual exit code of the process
#    print "reaped $waitedpid" . ($? ? " with exit $?" : '') . "\n";
}
