#!/bin/bash
#
# ravencore        Startup script for the RavenCore Hosting Control Panel
#
# chkconfig: - 85 15
# description: A Free Hosting Control Panel
# processname: ravencore.httpd
# config: /usr/local/ravencore/etc/ravencore.httpd.conf
# pidfile: /var/run/ravencore.httpd.pid

# we don't want to require a database connection, so say we already have one
# so bash_functions doesn't attempt to read the database configuration

export GOT_CONF=1

. /etc/ravencore.conf || exit 1

# tell our checkconf scripts that the init script is running, so services
# don't need to be restarted by them.
export INIT_RUNNING=1

# tells us if we found source function library for init scripts. Initilize it to zero

found_init_func=0

# Source function library for init scripts.
if [ -f $INITD/functions ]; then

    found_init_func=1
    . $INITD/functions

else

# declare some of the functions we used from the library we didn't find

    success() {

	echo "[ OK ]"
	
    }

    failure() {

	echo "[ FAILED ]"
	
    }

fi


# This will prevent initlog from swallowing up a pass-phrase prompt if
# mod_ssl needs a pass-phrase from the user.
INITLOG_ARGS=""

httpd=$RC_ROOT/sbin/ravencore.httpd
pidfile=${PIDFILE-/var/run/ravencore.httpd.pid}
lockfile=${LOCKFILE-/var/lock/subsys/ravencore.httpd}
RETVAL=0

# set $opt to whatever $2 is
# right now, only parameter is "nossl"

ssl_opt=$2

# if the var/run/httpd.nossl exists, force ssl_opt to be nossl
if [ -f $RC_ROOT/var/run/httpd.nossl ]; then
    ssl_opt="nossl"
fi

# The semantics of these two functions differ from the way apachectl does
# things -- attempting to start while running is a failure, and shutdown
# when not running is also a failure.  So we just do it the way init scripts
# are expected to behave here.
start() {

# check to see that mysqld is running....

    if [ -z "$(pidof mysqld)" ]; then
	
# mysqld isn't running.. attempt to start it
# don't run this command if the script doesn't exist... to supress the error message
	if [ -f $INITD/$mysql_service ]; then
	    $INITD/$mysql_service start
	fi

    fi

# check to make sure the ravencore.httpd binary is the same as /usr/sbin/httpd
# among other things

    $RC_ROOT/sbin/checkconf

    RETVAL=$?

# the checkconf script exits with non zero status, then something fatal is wrong

    if [ $RETVAL -ne 0 ]; then

	echo "Unable to start control panel. checkconf script exited with non-zero status"
	failure
	echo
	exit $RETVAL

    fi

# say we're starting up...

    echo -n $"Starting control panel: "

# check httpd version series. The result of this command will look like: 1.3 , 2.0 , etc
    httpd_v=$($httpd -v | sed '2d' | awk '{print $3}' | sed 's|.*/||' | sed 's/\./ /g' | awk '{print $1"."$2}')

# check to make sure the conf file exists for this version of apache

    if [ ! -f $RC_ROOT/etc/ravencore.httpd-$httpd_v.conf ]; then

	echo "Unable to load ravencore's httpd conf file: $RC_ROOT/etc/ravencore.httpd-$httpd_v.conf"
	failure
	echo
	exit 1

    fi

# make sure the docroot.conf file is populated
echo "DocumentRoot $RC_ROOT/httpdocs" > $RC_ROOT/etc/docroot.conf

# set our runtime options
# conf file is different depending on the httpd version
    OPTIONS="$OPTIONS -d $RC_ROOT -f etc/ravencore.httpd-$httpd_v.conf"

# check for compiled-in modules, and include the ones that are not, that we need to function

# get the list from the apache binary
    compiled_modules=`$httpd -l`

    for module in log_config setenvif mime autoindex negotiation dir actions alias include; do

	if [ -z "$(echo $compiled_modules | grep $module)" ]; then

	    OPTIONS="$OPTIONS -D$module"

	fi

    done

# check to make sure our httpd_modules symlink is correct

    if [ ! -L $RC_ROOT/etc/httpd_modules ]; then

# make sure that the httpd_modules.path directory exists
	
	httpd_modules=$(cat $RC_ROOT/var/run/httpd_modules.path 2> /dev/null)

	if [ -d $httpd_modules ]; then

# re-create the symlink
	    
	    rm -f $RC_ROOT/etc/httpd_modules
	    ln -s $httpd_modules $RC_ROOT/etc/httpd_modules

	else

# can't find the httpd modules directory. exit with error

	    echo "Unable to determine the path to the httpd modules"
	    failure
	    echo
	    exit 1

	fi

    fi

# only load PHP if we have it installed. If it isn't installed, our no_php.html will show up as the
# default index page of the control panel

# php5 listed first, because on a test system with both php5 and php4 libs installed, mysql only worked with
# php5 loaded
    
    if [ -f $RC_ROOT/etc/httpd_modules/libphp5.so ]; then
	
	OPTIONS="$OPTIONS -DPHP5"
	
    elif [ -f $RC_ROOT/etc/httpd_modules/libphp4.so ]; then

        OPTIONS="$OPTIONS -DPHP4"

    else

# couldn't find php. Obviously a bad thing :)

	echo -n " (no php)"
	
    fi
    
# figure out what our ssl shared object file is
    ssl_file=$(ls $RC_ROOT/etc/httpd_modules/*ssl.so 2> /dev/null | head -n 1)
    
# if we have ssl installed, enable it when we start the control panel
    if [ -x "$ssl_file" ]; then
# the user has the option to disable the ssl on the command line, or in $RC_ROOT/var/run/httpd.nossl
	case $ssl_opt in
	    "nossl") echo -n " (no ssl)";;
	    *) 
# if we are missing a cert or key file, don't attempt to start with ssl
		if [ ! -f $RC_ROOT/etc/server.crt ] || [ ! -f $RC_ROOT/etc/server.key ]; then
		    echo
		    echo "Warning: ssl cert and/or key file missing. Starting with no ssl"
		else
# if we have the openssl command, verify that the .crt file is OK
		    if [ -x /usr/bin/openssl ]; then
			
			/usr/bin/openssl verify $RC_ROOT/etc/server.crt &> /dev/stdout | grep OK &> /dev/null

# exit status of grep will be non-zero if we didn't find an OK, which means the cert won't work

			if [ $? -ne 0 ]; then
			    
			    echo
			    echo "Warning: Unable to verify the server.crt file. Starting with no ssl"

			else
			    
# the server.crt file appears to be OK. Start with SSL

			    OPTIONS="$OPTIONS -DSSL"

			fi
			
		    else

# we get here if we don't have the openssl command. Assume that the server.crt file will work

			OPTIONS="$OPTIONS -DSSL"

		    fi

		fi
		;;

	esac
	
    else
# notify us that we are not useing ssl, b/c it's not installed
	echo -n " (no ssl)"
    fi

# unset these enviroment variables so they don't get set in the apache enviroment
    
    export INIT_RUNNING= GOT_CONF=
    
# start the control panel daemon

if [ $found_init_func -eq 1 ]; then

    daemon $httpd $OPTIONS
    RETVAL=$?
    echo
    [ $RETVAL = 0 ] && touch ${lockfile}

else

    $httpd $OPTIONS
    RETVAL=$?

    if [ $RETVAL -eq 0 ]; then

	echo "[ OK ]"

    else

	echo "[ FAILED ]"

    fi

fi
    
    return $RETVAL
    
}

stop() {

    echo -n $"Stopping control panel: "

    if [ $found_init_func -eq 1 ]; then

	killproc $httpd
	RETVAL=$?
	echo
	[ $RETVAL = 0 ] && rm -f ${lockfile} ${pidfile}

    else

	killall -9 $httpd &> /dev/null
	RETVAL=$?

	if [ $RETVAL -eq 0 ]; then
	    
	    success
	    
	else
	    
	    failure
	    
	fi

    fi

}
startall() {

    for i in `ls $RC_ROOT/etc/services.*`; do

	tmp=$(basename $i | sed 's/services\.//')

	conf=$tmp.conf
	for service in $(cat $RC_ROOT/etc/services.$tmp); do
	    
	    if [ -f $RC_ROOT/conf.d/$conf ]; then
		
		$INITD/$service status &> /dev/null
	    
		if [ $? -ne 0 ]; then
		    
		    $INITD/$service start
		    
		fi
		
	    fi
	    
	done

    done

# start ravencore, too

    start

}

stopall() {

    for i in `ls $RC_ROOT/etc/services.*`; do

	tmp=$(basename $i | sed 's/services\.//')

	conf=$tmp.conf
	for service in $(cat $RC_ROOT/etc/services.$tmp); do
	    
	    if [ -f $RC_ROOT/conf.d/$conf ]; then
		
		$INITD/$service status &> /dev/null
		
		if [ $? -eq 0 ]; then
		    
		    $INITD/$service stop
		    
		else
		    
		    $INITD/$service status
		    
		fi

	    fi
		
	done

    done

# stop ravencore, too

    stop

}

statusall() {

    for i in `ls $RC_ROOT/etc/services.*`; do

	tmp=$(basename $i | sed 's/services\.//')

	conf=$tmp.conf
	for service in $(cat $RC_ROOT/etc/services.$tmp); do
	    
	    if [ -f $RC_ROOT/conf.d/$conf ]; then
		
		$INITD/$service status

	    fi

	done

    done

# status of ravencore, too

    $INITD/ravencore status

}

# See how we were called.
case "$1" in
    start)
	start
	;;
    stop)
	stop
	;;
    status)
        status $httpd
	RETVAL=$?
	;;
    restart)
	stop
	start
	;;
    startall)
	startall
	;;
    stopall)
	stopall
	;;
    restartall)
	stopall
	startall
	;;
    statusall)
	statusall
	;;
  *)
	echo $"Usage: $prog {start|stop|restart|status|stopall|startall|restartall}statusall}"
	exit 1
esac

exit $RETVAL
