#
#                  RavenCore Hosting Control Panel
#                Copyright (C) 2005  Corey Henderson
#
#     This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
#

# Set global variables for bash scripts

verbose=0

# when ran from the wrapper we don't have a path. export it here
export PATH="/sbin:/bin:/usr/sbin:/usr/bin"

# make sure the $RC_ROOT directory exists

if [ ! -d $RC_ROOT ]; then

	logger "RavenCore root directory $RC_ROOT doesn't exist"

	exit 1

fi

# make sure paths and variables are correctly set

for tmp in httpd:HTTPD init.d:INITD httpd_modules:HTTPD_MODULES; do

# each value is ext:var

    ext=$(echo $tmp | sed 's/:.*//')
    var=$(echo $tmp | sed 's/.*://')

# set the variable

    eval $var=$(cat $RC_ROOT/var/run/$ext.path 2> /dev/null)

# check to make sure the variable exists

    if [ ! -f "$(eval echo \$$var)" ] || [ ! -d "$(eval echo \$$var)" ]; then

        for i in $(cat $RC_ROOT/etc/paths.$ext.local $RC_ROOT/etc/paths.$ext 2> /dev/null); do

# the values in tis loop are either files or directories. If we get to the point where we need to
# have a difference, we'll just create two loops, one with a -f and the other with a -d

            if [ -f $i ] || [ -d $i ]; then

                eval $var=$i

                echo $i > $RC_ROOT/var/run/$ext.path

                break

            fi

        done

    fi

# if we get here and the value of $var is not set as a variable, die with an error

    if [ -z $(eval "if [ -n \"\$$var\" ]; then echo hello; fi") ]; then

        echo "System variable $var is unset, unable to determine path"

        exit 1

    fi

done

# set the name of the system init script for apache. for now, assume it's the basename
# of the $HTTPD path

HTTPD_INIT=$(basename $HTTPD)

# make sure database.cfg and .shadow exist
touch $RC_ROOT/database.cfg $RC_ROOT/.shadow

# load the database config file

. $RC_ROOT/database.cfg

# The password should be contained on a single line in a file readable only by rcadmin
MYSQL_ADMIN_PASS=$(cat $RC_ROOT/.shadow)

# This is the string which is used to connect to the database
MYSQL_STR="mysql -h $MYSQL_ADMIN_HOST -u $MYSQL_ADMIN_USER -p$MYSQL_ADMIN_PASS $MYSQL_ADMIN_DB"

# find the real name of the service script to start mysqld

mysql_service=$(basename /etc/init.d/mysql*)

# function to die on mysql connect error, and log it to the system logger

mysql_die() {

    logger -t ravencore "Unable to connect to database"
    
    exit 1

}

# we export all our variables, so any subshells ran will have them. We only need to do this once

# check for our GOT_CONF variable, if it exists, we can assume our conf variables are already set

if [ -z "$GOT_CONF" ]; then

# This tests the database connection with the defined information
    $MYSQL_STR -e "select now()" &> /dev/null || mysql_die 

# get settings variables from database, and export them
    
    for i in `$MYSQL_STR -e "select concat(setting,'=',value) from settings" | sed '1d'`; do
	
	export $i
	
    done
    
# set our error num to zero for our conf check
    
    conf_err=0
    
# get required conf variables, and check for their existance
    
    for i in `cat $(for e in $(ls $RC_ROOT/conf.d); do if [ -x $RC_ROOT/conf.d/$e ]; then echo $RC_ROOT/conf.d/$e; fi; done) | grep -v "^#" | sed 's/=.*//g'`; do
	
	export | sed 's/=/ /g' | awk '{print $3}' | grep $i &> /dev/null

	if [ $? -ne 0 ]; then
	    
	    logger -t ravencore "non existant variable: $i"
	    
	    conf_err=1
	    
	fi
	
    done
    
# if conf_err is 1, we don't have all our required varieables. exit out w/ error
    
    if [ $conf_err -eq 1 ]; then
	
	logger -t ravencore "Unable to load all required settings from database, exiting."
	
        exit 1
	
    else 
	
# export our GOT_CONF variable so we don't need to do this agian
	
	export GOT_CONF=1
	
    fi
    
fi


# some defined variables that we can't change

WEB_SERVER_GROUP=servgrp

# The system user mail will run as
VMAIL_USER=vmail

# The system uid and gid of the mail user
VMAIL_UID=148
VMAIL_GID=148

# A function to echo the given input, if verbose is set to 1

v_echo() {

    if [ $verbose -eq 1 ]; then

        echo $1

    fi

}

# A function to do just what it says... rebuild a conf file

rebuild_conf_file() {

    conf=$1
    service=$2
    seperator=$3

    conf_basename=$(basename $conf)

    if [ -f $conf ] && [ -d $RC_ROOT/etc/$service/$conf_basename ]; then
	
	for i in `ls -1 $RC_ROOT/etc/$service/$conf_basename | grep -v '\.local$'`; do
	    
	    param_name="$RC_ROOT/etc/$service/$conf_basename/$i"
	    [ -f $param_name.local ] && param_name=$param_name.local
	    
	    case `cat $param_name` in
		"")
		    echo -e "$i$seperator"
		    ;;
		
		*)
		    cat $param_name | while read -r param_value; do
			
			echo -e "$i$seperator$param_value"
			
		    done
		    ;;
	    esac

	done > $RC_ROOT/var/tmp/$conf_basename.$$
	
	diff $conf $RC_ROOT/var/tmp/$conf_basename.$$ &> /dev/null
	
	if [ $? -ne 0 ]; then

# if the sys_orig file for the conf file doesn't exist,
	    if [ ! -f $conf.sys_orig ]; then

# then save the conf file as the sys_orig. This will preserve the system's origonal configuration
# so when we uninstall ravencore, they will be moved back
		mv $conf $conf.sys_orig

# tell ravencore that this sys_orig file was made by appending it to our sys_orig list
		echo "$service:$conf" >> $RC_ROOT/var/run/sys_orig_conf_files
	    
	    fi

	    rm -f $conf
	    
	    cp $RC_ROOT/var/tmp/$conf_basename.$$ $conf
	    
	    $INITD/$service restart &> /dev/null

	fi
	
	rm -f $RC_ROOT/var/tmp/$conf_basename.$$

    fi

}
